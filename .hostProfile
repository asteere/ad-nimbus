#!/bin/bash

# Host .profile
# Everything to do with using vagrant and building docker containers

# For foolish consistency use lowercase for function names
function vbm() {
    VBoxManage $*
}

function gvmi() {
    getvminfo $*
}

function v() {
    vagrant $*
}

function vs() {
    vagrant status $*
}

function vstatus() {
    vagrant status $*
}

function vgs() {
    vagrant global-status $*
}

function b2d() {
    boot2docker $*
}

function dps() {
    rundocker ps -a $*
}

function dpsa() {
    rundocker ps -a $*
}

function di() {
    rundocker images $*
}

function d() {
    rundocker $*
}

function vup() {
    cdad
    echo `date`: Creating cluster from Vagrantfile in folder `pwd`

    case "$1" in
    info|debug|warn|error)
        dbgLevel=$1
        export VAGRANT_LOG=$dbgLevel;
        shift 1
        ;;
    *)
        ;;
    esac

    vagrant up $* 2>&1 | tee /tmp/vup.log

    unset VAGRANT_LOG

    date
}

function vsh() {
    vagrant ssh core-0$1
}

function buildall() {
    deletenetlocationcontainer
    rundocker rmi `rundocker images | grep $DOCKER_USER | awk '{print $3}'`

    buildimage scratch

    buildimage confd
    buildimage nginx
    buildimage netlocation nodejs
    buildimage netlocation go
    buildimage consul

    buildimage aws cli

    buildimage jmeter
}

function prepnetlocationgo() {
    buildscratchimage

    # TODO: go get should get everything, build and install it
    cd $GOPATH
    go get github.com/oschwald/maxminddb-golang

    # Build netlocation statically
    rundocker run --rm -e "CGO_ENABLED=0" -e "GOOS=linux" \
        -v "$PWD":/go \
        -w /go golang:1.4-onbuild \
        go install -a -installsuffix cgo -ldflags '-s' github.com/mark-larter/netlocation 
}

function buildimage() {
    svc=$1
    svcDir=$svc

    # HACK: have all images built from the same function
    if test "$svc" == "$scratch"
    then
        buildscratchimage
        return
    fi

    origDir=$PWD
    cdad

    cd $1
    if test "$2" != ""
    then
        cd $2
        svc=${1}-${2}
        if test "$2" == "go"
        then
            if ! prepnetlocationgo; then
                return 1
            fi
        fi
    fi

    echo Building docker container $svc

    dockerTag=$DOCKER_USER/$svc:$svc

    svcTar="$adNimbusDir/registrySaves/$svc.tar"
    svcTarGz="$svcTar.gz"
    if test -f "$svcTarGz"
    then
        rundocker load -i $svcTarGz
    fi

    # this will result in two repositories $DOCKER_USER/$svc:latest and $svc:latest containing collections of images
    # Docker is run from the parent directory of the folder with the Dockerfile
    rundocker build --tag $dockerTag .
    if test ! $? == 0
    then
        return
    fi

    "$adNimbusDir"/adnimbus_registry/startAdNimbusRegistry.sh saveImage $svc

    dlogin
    if test "$?" != 0
    then
        return
    fi

    rundocker push $dockerTag

    cd $origDir > /dev/null
}

function getlistofvms() {
    VBoxManage list vms | awk '{print $1}' | sed 's/"//g'
}

function getvminfo() {
    for vm in  `getlistofvms | grep $1`
    do
        echo 
        echo '********************************************************'
        echo
        echo VM: $vm
        VBoxManage showvminfo $vm
    done 
}

function vdestroy() {
    date
    if test "$1" = ""
    then
        vboxes=`v status | grep -e docker -e virtualbox | awk '{print $1}'`
    else
        vboxes=$1
    fi

    for i in $vboxes
    do 
        v destroy --force $i

        machineDir="$VAGRANT_DOTFILE_PATH/machines/$i"
        if test -d "$machineDir"
        then
            rm -r "$machineDir"
        fi
    done

    # Handle use case where a user destroyed a vm individually and then wanted to destroy all of the vms
    if test "$1" = ""
    then
        rm -rf "$VAGRANT_DOTFILE_PATH"/machines/*
    fi

    vms=`getlistofvms | grep -v boot2docker`
    if test ! "$1" == ""
    then
        vms=`echo $vms | grep $1`
    fi

    for vm in $vms
    do 
        VBoxManage controlvm $vm poweroff 
        VBoxManage unregistervm --delete $vm
    done

    echo
    echo Remaining vms
    getlistofvms

    # See if vagrant has completely cleaned up. Use --prune as sometimes vagrant does completely clean up
    echo
    echo Vagrant global-status '--prune'
    vgs --prune

    # TODO: For some reason, vagrant status reports that the core-0* machines are not created vs reporting nothing
    #echo
    #echo vagrant status
    #vagrant status

    removenginxconftempfiles
    
    date
}

function setupdocker() {
    if test ! "$DOCKER_HOST" == ""
    then
        # boot2docker already setup
        return
    fi

    (which boot2docker) &> /dev/null
    if test "$?" == 0
    then
        b2dstatus=`boot2docker status 2>&1`
        echo boot2docker current status: $b2dstatus
        echo $b2dstatus | grep -q "machine not exist"
        if test $? == 0
        then
            echo boot2docker init
            boot2docker init
        elif test ! "$b2dstatus" == "running"
        then
            echo boot2docker up
            boot2docker up
        fi
        $(boot2docker shellinit)
    fi
}

function rundocker() {
    setupdocker

    docker $*
}

function dlogin() {
    docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PWD
}

function checkhostwebcontent() {
    hostIpAddr=`findHostIpAddr`

    nginxIpAddr=`cat "$adNimbusTmp"/nginx.ipaddr`
    nginxHostName=`ipAddrToMachineName $nginxIpAddr`
    coreosNginxPorts=`findmappedports $nginxGuestOsPort $nginxHostName`

    for port in $coreosNginxPorts
    do
        checkwebcontent $anIpAddr $port
        echo
    done
}

function findmappedports() {
    nginxGuestOsPortArg=$1

    if test "$2" == ""
    then
        # No coreos specified
        grep $nginxGuestOsPortArg /tmp/vup.log | grep "adapter 1" | awk '{print $4}'
    else
        #grep $1 /tmp/vup.log | grep $2 | grep "adapter 1" | awk '{print $4}'

        nginxHostName=$2
        vmId=`VBoxManage list vms | grep $nginxHostName | awk '{print $1}' | sed 's/"//g'` 
        VBoxManage showvminfo $vmId | grep $nginxGuestOsPortArg | \
            grep 'guest port' | sed -e 's/.*host port = //' -e 's/, .*//'
    fi
}

function ipAddrToMachineName() {
    echo $1 | sed 's/.*\([0-9]\)$/core-0\1/'
}

function findHostIpAddr() {
    ip addr | grep 'inet ' | grep -v -e 127.0 -e 172.17 | sed -e 's/.*inet //' -e 's/\/.*//'
}

function checkhostnetlocation() {
    hostIpAddr=`findHostIpAddr`

    # No args - find the nginx coreos hostname and then the nginx port that has been forwarded on that machine. 
    # 1 arg - user specified the nginx coreos port, find all the forwarded ports for that port. 
    #    Useful to test netlocation directly on all forwarded ports.
    # 2 args - user specified the host ip address and the nginx coreos port, find the forwarded port for that coreos port. 
    #   Useful to try other netlocation from other machines
    case "$#" in
    0)
        nginxIpAddr=`cat "$adNimbusTmp"/nginx.ipaddr`
        nginxHostName=`ipAddrToMachineName $nginxIpAddr`
        coreosNginxPorts=`findmappedports $nginxGuestOsPort $nginxHostName`
        ;;
    1)
        coreosNginxPorts=`findmappedports $1`
        ;;
    2)
        coreosNginxPorts=`findmappedports $2`
        hostIpAddr=$1
        ;;
    esac

    for anIpAddr in localhost $hostIpAddr
    do
        for port in $coreosNginxPorts
        do
            checknetlocation $anIpAddr $port
            echo
        done
    done
}

function resetAdNimbusDir() {
    export adNimbusDir="$VAGRANT_CWD"
    export adNimbusTmp="$adNimbusDir/tmp"
}

# Use this function when you want to create a tar file of the useful source code but not build artifacts
function createtar() {
    cd "$adNimbusDir"/..

    daProject=ad-nimbus
    gzFile=${daProject}_`date +%Y%m%d_%H%M%S`.tar.gz
    tar -zcvf $gzFile --exclude jmeter/jmeter*log \
        --exclude='.vagrant' \
        --exclude=.vagrant.d \
        --exclude='.git' \
        --exclude='.nfs*' \
        --exclude=nginx/.nginx.conf* \
        --exclude=registrySaves \
        --exclude=registry-dev \
        --exclude=tmp \
        --exclude=netlocation/nodejs/src/node_modules \
        --exclude=netlocation/data \
        --exclude=netlocation/go/data \
        $daProject 

    pwd
    ls -l $gzFile

    cd -
}

# Sanity checks to see if the user has their .profile setup correctly
if test "$VAGRANT_CWD" == ""
then
    echo This .profile assumes that VAGRANT_CWD has been exported and set it to your ad-nimbus folder on the host machine. 
    echo If VAGRANT_CWD is set, things like fleetctl status 'netlocation@1.service' will work. Thanks.
    echo For example:
    echo '    export VAGRANT_CWD=~/Research/asteere/ad-nimbus'
    echo Exiting.
    return
fi

if test ! -d "$VAGRANT_CWD"
then
    echo The environment variable "$VAGRANT_CWD" does not point to a valid folder, please set VAGRANT_CWD to your ad-nimbus folder and resource this .profile
    echo export VAGRANT_CWD="$VAGRANT_CWD"
    echo Exiting.
    return
fi

resetAdNimbusDir

maxMindFolder="$adNimbusDir/netlocation/data/maxMind"
for dataFile in GeoIP2-City.mmdb  GeoIP2-ISP.mmdb
do
    if test ! -f "$maxMindFolder/$dataFile" 
    then
        echo Error: Missing file $maxMindFolder/$dataFile.
        echo One or more of the MaxMind data files are missing from folder $maxMindFolder. 
        echo Ask someone on the ArchTech team for the files.
        return
    fi
done

# User's .profile or .bash_profile set up correctly, time to get to work

export VAGRANT_HOME="$adNimbusDir/.vagrant.d"
export VAGRANT_DOTFILE_PATH="$adNimbusDir/.vagrant"

# Pull in the common functions, etc.
. "$adNimbusDir"/.sharedProfile

# TODO: Do we want to always pull in the AWS functions?
. "$adNimbusDir"/.awsProfile

# Sourcing the adNimbusEnvironment will overwrite these variables
resetAdNimbusDir

cdad

# Make vagrant's key accessible to coreos 
# TODO: Is this needed with port forwarding?
if test "$VAGRANT_HOME"/insecure_private_key -nt "$adNimbusDir"/insecure_private_key
then
    cp "$VAGRANT_HOME"/insecure_private_key "$adNimbusDir"
fi

# Port forwarding should have been setup. This means that identities known to the host machine are known to the guests.
ssh-add -L | grep -q insecure_private_key
if test "$?" != 0
then
    ssh-add "$VAGRANT_HOME"/insecure_private_key > /dev/null 2>&1 
fi

# If you want to make the searchable-web-content project available clone the repo 
# https://github.com/asteere/searchable-web-content.git into ~/Research/searchable-web-content. 
# Or, set webContentDir separately.
if test -d "$HOME/Research/searchable-web-content"
then
    export webContentDir="$HOME/Research/searchable-web-content"
fi

if test -x `which aws`
then
    complete -C aws_completer aws
fi

which go 2>&1 > /dev/null
if test "$?" == "0"
then
    export GOPATH="$adNimbusDir/netlocation/go"
    # TODO: Document why GOROOT shouldn't be defined
    #export GOROOT=/usr/local/opt/go/libexec
    #PATH=$PATH:$GOROOT/bin
fi

if test "`uname -s`" == "Darwin"
then
    ulimit -n 65536
    ulimit -u 2048
fi

