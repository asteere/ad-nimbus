#!/bin/bash

# Host .profile
# Everything to do with using vagrant and building docker containers

# For foolish consistency use lowercase for function names
function vbm() {
    VBoxManage $*
}

function gvmi() {
    getvminfo $*
}

function v() {
    vagrant $*
}

function vs() {
    vagrant status $*
}

function vstatus() {
    vagrant status $*
}

function vgs() {
    vagrant global-status $*
}

function b2d() {
    boot2docker $*
}

function dps() {
    rundocker ps -a $*
}

function dpsa() {
    rundocker ps -a $*
}

function di() {
    rundocker images $*
}

function d() {
    rundocker $*
}

function vup() {
    cdad
    echo `date`: Creating cluster from Vagrantfile in folder `pwd`

    case "$1" in
    info|debug|warn|error)
        dbgLevel=$1
        export VAGRANT_LOG=$dbgLevel;
        shift 1
        ;;
    *)
        ;;
    esac

    vagrant up $* 2>&1 | tee /tmp/vup.log

    unset VAGRANT_LOG

    date
}

function vsh() {
    vagrant ssh core-0$1
}

function vssh() {
    vsh $1
}

function buildall() {
    buildconfd
    buildnginx
    buildnetlocation
    buildconsul
    builddevutils
}

function builddevutils() {
    buildcontainer devutils
}

function buildconfd() {
    buildcontainer confd
}

function buildconsul() {
    buildcontainer consul
}

function buildnginx() {
    buildcontainer nginx
}

function buildnetlocation() {
    buildcontainer netlocation
}

function buildcontainer() {
    svc=$1

    cdad

    echo Building docker container $svc

    dockerTag=$DOCKER_REGISTRY/$svc:$svc

    svcTar="$adNimbusDir/registrySaves/$svc.tar"
    svcTarGz="$svcTar.gz"
    if test -f "$svcTar"
    then
        runDocker load -s $svcTarGz
    fi

    # this will result in two repositories $DOCKER_REGISTRY/$svc:latest and $svc:latest containing collections of images
    rundocker build --tag $dockerTag $svc 
    if test ! $? == 0
    then
        return
    fi

    rundocker save -o $svcTar $dockerTag
    gzip $svcTar

    rundocker push $dockerTag

    cd - > /dev/null

}

function getlistofvms() {
    VBoxManage list vms | awk '{print $1}' | sed 's/"//g'
}

function getvminfo() {
    for vm in  `getlistofvms | grep $1`
    do
        echo 
        echo '********************************************************'
        echo
        echo VM: $vm
        VBoxManage showvminfo $vm
    done 
}

function vdestroy() {
    date
    if test "$1" = ""
    then
        vboxes=`v status | grep -e docker -e virtualbox | awk '{print $1}'`
    else
        vboxes=$1
    fi

    for i in $vboxes
    do 
        v destroy --force $i

        machineDir="$VAGRANT_DOTFILE_PATH/machines/$i"
        if test -d "$machineDir"
        then
            rm -r "$machineDir"
        fi
    done

    # Handle use case where a user destroyed a vm individually and then wanted to destroy all of the vms
    if test "$1" = ""
    then
        rm -rf "$VAGRANT_DOTFILE_PATH"/machines/*
    fi

    vms=`getlistofvms | grep -v boot2docker`
    if test ! "$1" == ""
    then
        vms=`echo $vms | grep $1`
    fi

    for vm in $vms
    do 
        VBoxManage controlvm $vm poweroff 
        VBoxManage unregistervm --delete $vm
    done

    echo
    echo Remaining vms
    getlistofvms

    # See if vagrant has completely cleaned up. Use --prune as sometimes vagrant does completely clean up
    echo
    echo Vagrant global-status '--prune'
    vgs --prune

    # TODO: For some reason, vagrant status reports that the core-0* machines are not created vs reporting nothing
    #echo
    #echo vagrant status
    #vagrant status

    removenginxconftempfiles
    
    date
}

function setupdocker() {
    if test ! "$DOCKER_HOST" == ""
    then
        # boot2docker already setup
        return
    fi

    (which boot2docker) &> /dev/null
    if test "$?" == 0
    then
        b2dstatus=`boot2docker status 2>&1`
        echo boot2docker current status: $b2dstatus
        echo $b2dstatus | grep "machine not exist" 2>&1 > /dev/null
        if test $? == 0
        then
            echo boot2docker init
            boot2docker init
        elif test ! "$b2dstatus" == "running"
        then
            echo boot2docker up
            boot2docker up
        fi
        $(boot2docker shellinit)
    fi
}

function rundocker() {
    setupdocker

    docker $*
}

function dlogin() {
    docker login -e $DOCKER_EMAIL -u $DOCKER_USER -p $DOCKER_PWD
}

function checkhostwebcontent() {
    hostIpAddr=`findHostIpAddr`

    nginxIpAddr=`cat "$adNimbusTmp"/nginx.ipaddr`
    nginxHostName=`ipAddrToMachineName $nginxIpAddr`
    coreosNginxPorts=`findmappedports $nginxGuestOsPort $nginxHostName`

    for port in $coreosNginxPorts
    do
        checkwebcontent $anIpAddr $port
        echo
    done
}

function findmappedports() {
    nginxGuestOsPortArg=$1

    if test "$2" == ""
    then
        # No coreos specified
        grep $nginxGuestOsPortArg /tmp/vup.log | grep "adapter 1" | awk '{print $4}'
    else
        #grep $1 /tmp/vup.log | grep $2 | grep "adapter 1" | awk '{print $4}'

        nginxHostName=$2
        vmId=`VBoxManage list vms | grep $nginxHostName | awk '{print $1}' | sed 's/"//g'` 
        VBoxManage showvminfo $vmId | grep $nginxGuestOsPortArg | \
            grep 'guest port' | sed -e 's/.*host port = //' -e 's/, .*//'
    fi
}

function ipAddrToMachineName() {
    echo $1 | sed 's/.*\([0-9]\)$/core-0\1/'
}

function findHostIpAddr() {
    ip addr | grep 'inet ' | grep -v -e 127.0 -e 172.17 | sed -e 's/.*inet //' -e 's/\/.*//'
}

function checkhostnetlocation() {
    hostIpAddr=`findHostIpAddr`

    # No args - find the nginx coreos hostname and then the nginx port that has been forwarded on that machine. 
    # 1 arg - user specified the nginx coreos port, find all the forwarded ports for that port. 
    #    Useful to test netlocation directly on all forwarded ports.
    # 2 args - user specified the host ip address and the nginx coreos port, find the forwarded port for that coreos port. 
    #   Useful to try other netlocation from other machines
    case "$#" in
    0)
        nginxIpAddr=`cat "$adNimbusTmp"/nginx.ipaddr`
        nginxHostName=`ipAddrToMachineName $nginxIpAddr`
        coreosNginxPorts=`findmappedports $nginxGuestOsPort $nginxHostName`
        ;;
    1)
        coreosNginxPorts=`findmappedports $1`
        ;;
    2)
        coreosNginxPorts=`findmappedports $2`
        hostIpAddr=$1
        ;;
    esac

    for anIpAddr in localhost $hostIpAddr
    do
        for port in $coreosNginxPorts
        do
            checknetlocation $anIpAddr $port
            echo
        done
    done
}

function resetAdNimbusDir() {
    export adNimbusDir="$VAGRANT_CWD"
    export adNimbusTmp="$adNimbusDir/tmp"
}

function cptoawsesb() {
    clitoawsesb cp --recursive 
}

function synctoawsesb() {
    clitoawsesb sync --delete
}

function clitoawsesb() {
    cmd=$1
    opt1=$2

    # This was helpful: http://docs.aws.amazon.com/cli/latest/reference/s3/index.html
    aws s3 $cmd $adNimbusDir s3://ad-nimbus-bucket/ad-nimbus $opt1 --exclude '.git/*' --exclude 'tmp/*' --exclude 'registery-dev/*' --exclude '.vagrant/*' --exclude '.vagrant.d/*' --exclude 'insecure_private_key' --exclude '.gitignore' --exclude '.DS_Store' --exclude '.*.swp'
}

function awssetup() {
    # us-west2 coreos HVM image: ami-c5162ef5 
    export imageId=`cat $imageIdFile`

    export securityGroup=AdNimbusUsWest2-CoreOSSecurityGroup-Y3ZSINO39RK5 

    if test ! -f "$stackNameFile"
    then
        timestamp=`date +"%Y%m%d-%H%M"`
        echo "AdNimbus-${imageId}-${timestamp}-CoreOS-stable" > "$stackNameFile"
    fi 
    export stackName=`cat $stackNameFile`
}

function awscreateimage() {
    if test "$1" == ""
    then
        echo Error: To create the image, I need the private ip address of the instance
        return 1
    fi

    awssetup

    instanceId=`aws ec2 describe-instances --filters "Name=private-ip-address,Values=$1" | \
        grep InstanceId | \
        sed -e 's/.*: "//' -e 's/",//'`

    timestamp=`date +"%Y%m%d-%H%M"`
    aws ec2 create-image --instance-id $instanceId --name "AdNimbus_${timestamp}" --description "TBD" | tee /tmp/imageId

    grep ImageId /tmp/imageId | sed -e 's/.*: "//' -e 's/"//' > "$imageIdFile"
}

function awsvalidatetemplate() {
    templateFile=$1
    if test "$1" == ""
    then
        echo Error: Missing full path to template file
        templateFile=$adNimbusDir/aws/AdNimbusUsWest2_CloudFormation.json
    fi
    aws cloudformation validate-template --template-body file://$templateFile
}

function myip() {
    curl -s ifconfig.me
}

function awscreatestack() {
    # Args: imageId numInstances
    if test ! -f "$stackNameFile"
    then
        rm "$stackNameFile"
        if test "$?" != 0
        then
            echo Error: Unable to delete file $stackNameFile
            return 1
        fi
    fi

    if [[ "$1" == "ami-"* ]]
    then
        echo $1 > "$imageIdFile"
        shift 1
    fi

    if [[ "$1" == [0-9]* ]]
    then
        numInstances=$1
    else
        numInstances=3
    fi

    awssetup

    allowSshFrom=`myip`/32
    echo If ssh to public IP address gets \"Connection refused\", is $allowSshFrom in the security group $securityGroup inbound rules

    echo
    newToken=`curl -s https://discovery.etcd.io/new`
    echo newToken $newToken
    curlNewToken $newToken

    stackTemplate=$adNimbusDir/aws/AdNimbusUsWest2_CloudFormation.json 
    sed -e 's|https://discovery.etcd.io/.*|'$newToken'\\n",|' \
        -e 's/\(.*ImageId" : "\).*/\1'$imageId'",/' \
        -e 's/\(.*DesiredCapacity.: .\)./\1'$numInstances'/' \
        ${stackTemplate}.tmpl > $stackTemplate

    echo
    echo diff ${stackTemplate}.tmpl $stackTemplate
    diff ${stackTemplate}.tmpl $stackTemplate

    echo
    awsvalidatetemplate $stackTemplate

    grep "$newToken" $stackTemplate 2>&1 > /dev/null
    if test "$?" != 0
    then
        echo Error: new token insertion failed
        return 1
    fi

    echo
    echo aws cloudformation create-stack --stack-name $stackName --template-body file://$stackTemplate
    aws cloudformation create-stack --stack-name $stackName --template-body file://$stackTemplate 
    # TODO: Is this option useful: --generate-cli-skeleton 
    if test "$?" != "0"
    then
        return 1
    fi

    echo
    awsdescribeinstances

    echo
    mywatch.sh -g -n 2 awsgetipaddresses

    awsgetipaddresses

    curlNewToken $newToken
}

function curlNewToken() {
    curl -s "$1" | jq "."
}

function awsdeletestack() {
    awssetup

    if  test "$1" != ""
    then
        stackName=$1
    else
        awssetup
        rm -f $"stackNameFile"
    fi

    #stackId=`awsdescribestack | grep StackId | sed -e "s/.*$stackName.//" -e 's/",//'`
    echo aws cloudformation delete-stack --stack-name $stackName
    aws cloudformation delete-stack --stack-name $stackName
}

function awsdescribestack() {
    awssetup

    aws cloudformation describe-stacks --stack-name $stackName
}


function awsdescribestackevents() {
    awssetup

    aws cloudformation describe-stack-events --stack-name $stackName
}

function awsliststacks() {
    aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE
}

function awsupdateuserdata() {
    numInstances=3
    newToken=`curl -L -s https://discovery.etcd.io/new?size=$numInstances`
    echo Using discovery token $newToken
    sed "s|https://discovery.etcd.io/.*|$newToken|" user-data.tmpl > aws/user-data-aws
}

function awsstartcluster() {
    awssetup

    awsupdateuserdata

    numInstances=3
    aws ec2 run-instances --image-id $imageId --count $numInstances --instance-type t2.micro --key-name AdNimbusUsWest2 --security-groups $securityGroup --user-data "file://$adNimbusDir/aws/user-data-aws"

    if test $? != 0
    then
        exit $?
    fi

    sleep 5

    awsgetipaddresses
}

function awsdescribeinstances() {
    aws ec2 describe-instances --filters "Name=instance-state-name,Values=running" 
}

function awsgetipaddresses() {
    awsdescribeinstances | grep PublicIpAddress | sed -e 's/.*": "//' -e 's/",//'
}

function awsgetprivateipaddresses() {
    awsdescribeinstances | grep '"PrivateIpAddress": "' | grep ',' | sed -e 's/.*": "//' -e 's/".//' 
}

function awsopenssh() {
    rm -f /tmp/ssh_*
    for awsIpAddr in `awsgetipaddresses`
    do  
        sshScript=/tmp/ssh_$awsIpAddr
        printf '#! /bin/bash\n    ssh core@'$awsIpAddr' -t \n bash -l\n' > $sshScript
        chmod +x $sshScript
        open -a Terminal.app $sshScript
    done
}

function awsscpadnimbus() {
    tarFile="`ls -t $adNimbusDir/../aws_*tar.gz | head -1`"
    for awsIpAddr in `awsgetipaddresses` 
    do 
        scp "$tarFile" core@$awsIpAddr:/home/core
    done
}

function awscreatesecuritygroup() {
    aws ec2 create-security-group --group-name "AdNimbusSecurityGroup" 
}

function awsterminatecluster() {
    instanceIds=`awsdescribeinstances | grep InstanceId | sed -e 's/.*": "//' -e 's/",//'`

    for instanceId in $instanceIds
    do
        aws ec2 terminate-instances --instance-ids $instanceIds
    done

}

# Use this function when you want to create a tar file of the artifacts needed for an aws image
function awscreatetar() {
    cd "$adNimbusDir"/..

    daProject=ad-nimbus
    gzFile=aws_${daProject}_`date +%Y%m%d_%H%M%S`.tar.gz
    tar -zcvf $gzFile --exclude LoadTests/JMeter/jmeter*log \
        --exclude='.vagrant' \
        --exclude=.vagrant.d \
        --exclude='.git' \
        --exclude=nginx/.nginx.conf* \
        --exclude=registrySaves \
        --exclude=registry-dev \
        --exclude=netlocation/go \
        --exclude=netlocation/src/node_modules \
        --exclude=tmp \
        $daProject ~/.ssh/AdNimbusPrivateIPKeyPairUsWest2.pem

    pwd
    ls -l $gzFile

    cd -
}

# Use this function when you want to create a tar file of the useful source code
function createtar() {
    cd "$adNimbusDir"/..

    daProject=ad-nimbus
    gzFile=${daProject}_`date +%Y%m%d_%H%M%S`.tar.gz
    tar -zcvf $gzFile --exclude LoadTests/JMeter/jmeter*log \
        --exclude='.vagrant' \
        --exclude=.vagrant.d \
        --exclude='.git' \
        --exclude=nginx/.nginx.conf* \
        --exclude=registrySaves \
        --exclude=registry-dev \
        --exclude=tmp \
        --exclude=netlocation/src/node_modules \
        --exclude=netlocation/src/maxMind \
        $daProject 

    pwd
    ls -l $gzFile

    cd -
}

if test "$VAGRANT_CWD" == ""
then
    echo This .profile assumes that VAGRANT_CWD has been exported and set it to your ad-nimbus folder on the host machine. 
    echo If VAGRANT_CWD is set, things like fleetctl status 'netlocation@1.service' will work. Thanks.
    echo For example:
    echo '    export VAGRANT_CWD=~/Research/asteere/ad-nimbus'
    echo Exiting.
    return
fi

if test ! -d "$VAGRANT_CWD"
then
    echo The environment variable "$VAGRANT_CWD" does not point to a valid folder, please set VAGRANT_CWD to your ad-nimbus folder and resource this .profile
    echo export VAGRANT_CWD="$VAGRANT_CWD"
    echo Exiting.
    return
else
    resetAdNimbusDir
fi

# AWS folders
export imageIdFile="$adNimbusDir/aws/imageIdFile"
export stackNameFile=$adNimbusDir/aws/stackName

maxMindFolder="$adNimbusDir/netlocation/src/data/maxMind"
for dataFile in GeoIP2-City.mmdb  GeoIP2-ISP.mmdb
do
    if test ! -f "$maxMindFolder/$dataFile" 
    then
        echo Error: Missing file $maxMindFolder/$dataFile.
        echo One or more of the MaxMind data files are missing from folder $maxMindFolder. 
        echo Ask someone on the ArchTech team for the files.
        return
    fi
done

if test "$DOCKER_REGISTRY" == ""
then
    echo Please set and export DOCKER_REGISTRY in your ~/.profile to the docker registry you want to use '(asteere, mark-larter, localhost:5000, etc.)'.
    echo Exiting
    return
fi

if test "$DOCKER_USER" == ""
then
    echo Please set and export DOCKER_USER in your ~/.profile to the docker registry user you want to use '(asteere, mark-larter, etc.)'.
    echo Exiting.
    return
fi

# User's .profile or .bash_profile set up correctly, time to get to work

export VAGRANT_HOME="$adNimbusDir/.vagrant.d"
export VAGRANT_DOTFILE_PATH="$adNimbusDir/.vagrant"

# Pull in the common functions, etc.
. "$adNimbusDir"/.sharedProfile

# Sourcing the adNimbusEnvironment will overwrite these variables
resetAdNimbusDir

cdad

# Make vagrant's key accessible to coreos 
# TODO: Is this needed with port forwarding?
if test "$VAGRANT_HOME"/insecure_private_key -nt "$adNimbusDir"/insecure_private_key
then
    cp "$VAGRANT_HOME"/insecure_private_key "$adNimbusDir"
fi

# Port forwarding should have been setup. This means that identities known to the host machine are known to the guests.
ssh-add -L | grep insecure_private_key 2>&1 > /dev/null
if test "$?" != 0
then
    ssh-add "$VAGRANT_HOME"/insecure_private_key
fi

# If you want to make the WebContent Research available clone the repo into ~/Research/WebContent. 
# Or, define webContentDir separately.
if test -d "$HOME/Research/WebContent"
then
    export webContentDir="$HOME/Research/WebContent"
fi

if test -x `which aws`
then
    complete -C aws_completer aws
fi

which go 2>&1 > /dev/null
if test "$?" == "0"
then
    export GOPATH="$adNimbusDir/netlocation-go"
    export GOROOT=/usr/local/opt/go/libexec/bin
    PATH=$PATH:$GOPATH/bin:$GOROOT
fi


